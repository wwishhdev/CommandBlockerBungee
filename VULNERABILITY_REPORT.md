# Reporte de Vulnerabilidades y Observaciones

Este documento detalla los hallazgos tras un análisis exhaustivo del código fuente del proyecto `CommandBlockerBungee` y `CommandBlockerVelocity`.

## 1. Condición de Carrera en `CooldownManager` (Gravedad: Media)

### Descripción
Existe una condición de carrera en la lógica de limpieza de intentos de cooldown (`cleanupOldAttempts`) en `CooldownManager.java`.

### Ubicación
- `bungee/src/main/java/com/wish/commandblockerbungee/managers/CooldownManager.java`
- `velocity/src/main/java/com/wish/commandblockervelocity/managers/CooldownManager.java`

### Código Afectado
```java
private void cleanupOldAttempts() {
    long currentTime = System.currentTimeMillis();
    int resetAfter = configManager.getResetAfter();
    playerAttempts.entrySet().removeIf(entry ->
            (currentTime - entry.getValue().lastAttempt) / 1000 > resetAfter * 2);
}
```

### Explicación
La variable `lastAttempt` en la clase interna `CommandAttempts` no está marcada como `volatile` ni su acceso está sincronizado cuando se lee en el método `cleanupOldAttempts`.
Mientras el método `handleCooldown` actualiza `lastAttempt` (bajo sincronización del objeto `CommandAttempts`), el hilo de limpieza (`cleanupOldAttempts`) puede leer un valor obsoleto de `lastAttempt` debido a la falta de garantías de visibilidad de memoria entre hilos.

Si el hilo de limpieza lee un valor antiguo que cumple la condición de expiración (`> resetAfter * 2`), eliminará la entrada del mapa `playerAttempts`. Si esto ocurre justo después de que el jugador haya ejecutado un comando (y actualizado `lastAttempt` en otro hilo), se perderá el contador de intentos actual del jugador.
Como resultado, la siguiente ejecución de `handleCooldown` creará una nueva entrada con 0 intentos, permitiendo al jugador evadir temporalmente el bloqueo por cooldown.

### Recomendación
Hacer que el campo `lastAttempt` sea `volatile` o utilizar métodos sincronizados para acceder a él, o usar `AtomicLong`.

## 2. Inyección de Colores Hexadecimales en Notificaciones (Gravedad: Baja)

### Descripción
Es posible que los jugadores inyecten colores hexadecimales en las notificaciones enviadas al staff si el servidor soporta formatos de color modernos.

### Ubicación
- `bungee/src/main/java/com/wish/commandblockerbungee/managers/ConfigManager.java`
- `velocity/src/main/java/com/wish/commandblockervelocity/managers/ConfigManager.java`

### Código Afectado
```java
public String escape(String text) {
    if (text == null) return "";
    // Strip only valid legacy color codes (&c, &l, etc)
    String clean = text.replaceAll("(?i)&[0-9a-fk-or]", "");
    return miniMessage.escapeTags(clean);
}
```

### Explicación
El método `escape` elimina los códigos de color heredados estándar (`&a`, `&1`, etc.) usando una expresión regular. Sin embargo, no elimina patrones de colores hexadecimales (como `&#RRGGBB` o `&x...`) que pueden ser soportados por `LegacyComponentSerializer`.
Aunque `MiniMessage` se usa principalmente, el método `parse` recurre a `LegacyComponentSerializer` si no detecta etiquetas MiniMessage. Si un usuario introduce códigos hexadecimales en un comando bloqueado, estos podrían renderizarse como colores en la notificación al staff.

### Recomendación
Mejorar la expresión regular de limpieza para incluir formatos hexadecimales o utilizar un serializador que ignore estrictamente el formato heredado.

## 3. Construcción Manual de JSON en Webhook (Gravedad: Baja/Informacional)

### Descripción
La construcción del payload JSON para los webhooks de Discord se realiza mediante concatenación de cadenas en lugar de usar una librería de serialización JSON.

### Ubicación
- `bungee/src/main/java/com/wish/commandblockerbungee/managers/WebhookManager.java`
- `velocity/src/main/java/com/wish/commandblockervelocity/managers/WebhookManager.java`

### Explicación
Aunque el método `escapeJson` implementado cubre la mayoría de los casos (comillas, barras invertidas, caracteres de control), la construcción manual de JSON es propensa a errores humanos y vulnerabilidades sutiles si se introducen nuevos campos o si cambian los requisitos de escape. Por ejemplo, no maneja caracteres de control no estándar fuera del rango 0-31 (aunque JSON estándar no requiere escaparlos, es buena práctica).

### Recomendación
Utilizar una librería ligera como `Gson` o `Jackson` (si está disponible o sombrearla) para garantizar una serialización JSON robusta y estándar.

## 4. Potencial Agotamiento de Recursos en Webhooks (Gravedad: Baja/Informacional)

### Descripción
El `ExecutorService` utilizado para enviar webhooks es un `FixedThreadPool` (16 hilos) con una cola de tareas ilimitada.

### Ubicación
- `CommandBlockerBungee.java` / `CommandBlockerVelocity.java`

### Explicación
Si el endpoint del webhook (Discord) deja de responder o responde muy lentamente, las tareas se acumularán en la cola del ejecutor. Aunque existe un límite de tasa en la *adición* a la cola interna del `WebhookManager` (4/segundo), una vez que las tareas pasan al ejecutor, ya no están controladas.
Si el timeout de conexión es alto (10s) y el servicio está caído, los 16 hilos se bloquearán esperando respuesta, y las tareas subsiguientes se encolarán en memoria. Aunque el impacto es limitado debido al rate limit previo, bajo condiciones extremas podría consumir memoria innecesaria.

### Recomendación
Utilizar un `ThreadPoolExecutor` con una cola de tamaño limitado y una política de rechazo (DiscardPolicy) para evitar acumulación infinita de tareas.

## 5. Validación de Comandos (Observación)

### Descripción
La lógica de validación de comandos en `ChatListener` utiliza `split` y `trim` para normalizar la entrada.

### Explicación
El uso de `(?U)\\s+` para dividir argumentos es correcto para manejar espacios Unicode. Sin embargo, depender de la manipulación de cadenas para la seguridad de comandos es inherentemente frágil.
Se observó que el código maneja correctamente casos como `/ minecraft : op` normalizándolos, lo cual es positivo. No se encontraron vulnerabilidades directas de bypass con los métodos actuales, pero se recomienda precaución si se añaden más reglas de normalización.

---
**Nota:** El código en general muestra buenas prácticas como el uso de `PreparedStatement` para SQL y validación de prefijos de tablas, evitando las vulnerabilidades más críticas como SQL Injection.
